# 스위프트의 언어적 특성

> - 스위프트의 언어적 특성
> - 객체지향 프로그래밍 패러다임
> - 함수형 프로그래밍 패러다임
> - 프로토콜 지향 프로그래밍 패러다임
> - RxSwift

## 스위프트의 언어적 특성

- 애플이 최초에 스위프트를 발표했을 때 스위프트 언어의 특징을 safe, modern, powerful이라고 발표했다. 그러나 오픈소스로 전환되면서 특징을 safe, fast, expressive로 변경하여 발표했다

- Safe: 안전성
  - 소프트웨어가 배포되기 전, 프로그래밍하는 중에 프로그래머가 저지를 수 있는 실수를 엄격한 문법을 적용해 미연에 방지하고자 노력했음
  - 때론 너무 강제적이라고 느껴질 수 있지만 문법적 제재는 실수를 줄이는데 도움이 된다
  - 버그를 수정하거나 실수를 찾아내는 시간을 절약할 수 있음
  - Optional, guard 구문, 오류처리, 강력한 타입 통제 등을 통해 스위프틀는 안전한 프로그래밍을 구현하고 있다
  - 변수는 항상 사용 전에 초기화되면 배열과 정수는 오버플로우가 검사되고 메모리는 자동으로 관리된다
  - (var, let) 신택스는 프로그래머의 의도에 맞게 쉽게 정의할 수 있다
  - 또 다른 안전성을 알 수 있는 부분은 Swift의 객체가 절대 nil이 되지 않는다는 것. 실제로 Swift 컴파일러는 컴파일 오류가 있는 객체를 만들거나 사용하지 못하도록 한다
  
- Fast: 신속성
  - 스위프트는 C 언어를 기반으로 한 C, C++, Objective-C와 같은 프로그래밍 언어를 대체하려는 목적으로 만들어졌다
  - 아직은 미흡한 부분도 있지만 스위프트는 C언어 수준과 동등한 성능을 일정한 수준으로 유지하는데 초점을 맞춰 개발되었다
  - 실행 속도의 최적화뿐만 아니라 컴파일러를 지속적으로 개량해 더 빠른 컴파일 성능을 구현해 나가고 있다
  
- Expressive: 더 나은 표현성
  - 컴퓨터 과학 분야의 발전과 함께 성장한 수많은 프로그래밍 언어 각각의 문법은 다양한 장단점이 있다
  - 스위프트는 이런 장단점을 참고해 좀 더 사용하기 편하고 보기 좋은 문법을 구현하려 노력했다
  - 덕분에 개발자들이 원하던 현대적이고 세련된 문법을 구사할 수 있다
  - 그러나 지금의 스위프트가 끝이 아니고 계속된 업데이트를 통해 더욱 보기 좋고 쓰기 좋은 언어로 발전해 나갈 것이다
  - 제네릭 메소드와 extensions, 프로토콜을 지원하는 구조체
  
- 스위프트, 다중 패러다임 프로그래밍 언어
  
  - Swift는 함수형 패러다임을 차용한 언어이며 클로저를 사용한다
  - 명령형과 객체지향 프로그래밍 패러다임을 기반으로 한 함수형 프로그래밍 패러다임과 프로토콜 지향 프로그래밍 패러다임을 지향한다
  - 명령형 프로그래밍 패러다임 / 객체지향 프로그래밍 패러다임 / 함수형 프로그래밍 패러다임 / 프로토콜 지향 프로그래밍 패러다임 차용
  - 결과적으로 스위프트에서 가장 강조하는 부분은 함수형 프로그래밍 패러다임과 프로토콜 지향 프로그래밍 패러다임이다
  
- 기존의 C언어는 명령형 프로그래밍 패러다임을 차용했으며, C++, 자바 등의 언어는 명령형 프로그래밍 패러다임과 객체지향 프로그래밍 패러다임을 동시에 차용한 다중 프로그래밍 패러다임 언어이다. 스위프트는 여기에 함수형 프로그래밍 패러다임과 프로토콜 지향 프로그래밍 패러다임을 더한 언어라고 생각하면 된다

- Objective-C와의 상호운용성도 뛰어남. Swift를 사용하면 완전히 새로운 응용프로그램을 만들 수 있지만 Objective-C파일과 함께 스위프트 파일이 공존할 수 있으며 Objective-C api에 완전히 접근 가능함

- #### 참고) 스위프트가 함수형 프로그래밍 패러다임을 차용한 의의

  - 사실 각각의 프로그래밍 패러다임 자체도 정의하기 어렵거니와 어떤 언어에 어떠한 프로그래밍 패러다임이 있다고 딱 잘라 말하기도 쉽지 않다
  - 그렇지만 애플이 스위프트를 공개하며 발표한 내용을 살펴보면 스위프트는 분명 객체지향 프로그래밍 패러다임과 함수형 프로그래밍 패러다임을 모두 차용하고 있음
  - 사실 애플의 프레임워크 대부분은 객체지향 프로그래밍 패러다임을 기반으로 설계된 수많은 클래스로 구성되어 있다. 따라서 애플의 프레임워크에서 사용될 언어가 객체지향 프로그래밍 패러다임을 수용하지 않는다면 당연히 문제가 발생할 것이다
  - 하지만 애플은 스위프트에서 함수형 프로그래밍 패러다임을 특히나 강조한다. 이는 애플의 프레임워크를 벗어나 다른 영역(예를 들면 서버용 프레임워크 등)에서 스위프트를 사용했을 때 순수하게 함수형 프로그래밍 패러다임만으로 프로그램을 작성할 수 있기 때문
  - 순수하게 함수형 프로그래밍 패터다임으로 프로그램을 작성하면 다음과 같은 장점 있음
    - 여러가지 연산 처리 작업이 동시에 일어나는 프로그램을 만들기 쉬움
    - 멀티 코어 혹은 여러개 연산 프로세서를 사용하는 시스템에서 효율적인 프로그램을 만들기 쉬움
    - 상태변화에 따른 부작용에서 자유로워지므로 순수하게 기능 구현에 초점을 맞추어 설계할 수 있음
    - 때에 따라 적절하게 객체지향과 함수형 프로그래밍 패러다임을 섞어 프로그램을 작성한다면 필요한 기능에 맞게 최적의 성능을 발휘할 수 있고, 생산성도 극대화할 수 있는 프로그램을 만들 수 있음
  - 근래에는 스위프트 뿐만 아니라 객체지향 프로그래밍 패러다임을 기반으로 구현된 프로그래밍 언어 중에서도 함수형 프로그래밍이 가능하도록 버전이 업데이트된 언어도 생겨나는 추세임. 자바 8, C# 3.0

## 객체지향 프로그래밍 패러다임

- 객체지향 프로그래밍 OOP(Objected Oriented Programming)

  - 현대 프로그래밍 언어에서 대부분 차용
  - 객체지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 기존의 명령형 프로그래밍 패러다임의 시각에서 벗어나 여러 개의 독립된 단위인 객체의 모임으로 파악하고자 하는 시각이다
  - 각각의 객체는 서로 메세지를 주고 받고 데이터를 처리할 수 있다
  - 객체지향 프로그래밍은 프로그램을 유연하고 쉽게 변경할 수 있도록 작성할 수 있어 대규모 소프트웨어 개발에 많이 사용된다
  - 또한, 객체만 잘 이해하면 프로그래밍을 더 쉽게 배울 수 있고 소프트웨어 개발과 유지보수를 간편하게 할 수 있으며, 직관적으로 코드를 분석할 수 있다는 장점이 있다
  - 객체지향 프로그래밍의 주요 특징으로는 자료 추상화, 상속, 다형성, 동적 바인딩 등이 있음
  - 객체지향 프로그래밍 패러다임을 차용한 언어는 Smalltalk, Objective-C, C++, C#, 자바, 파이썬, 루비, 스위프트 등이 있다

- 소프트웨어의 질을 향상하기위해 강한 응집력Strong Cohesion과 약한 결합력Weak Coupling을 지향

  - 객체지향 프로그래밍은 클래스에 하나의 문제 해결을 위한 데이터와 메소드를 모아놓은 방식으로 응집력을 강화한다
  - 또, 각 클래스는 독립적이 되도록 디자인해 결합력을 약화한다

- 그러나 실제 세계의 모습을 프로그램 안에 구현하고자 했던 객체지향 프로그래밍 패러다임이지만, 지나친 프로그램의 객체화 경향 때문에 오히려 실제 세계의 모습을 그대로 반영하기 어렵다는 비판을 받았음

- 클래스

  - 같은 종류의 집단에 속하는 속성과 행위를 정의한 것
  - 객체지향 프로그램의 기본 사용자정의 데이터 타입이라고 할 수 있음
  - 클래스는 다른 클래스 또는 외부 요소와 독립적으로 디자인되어야한다

- 객체

  - 클래스의 인스턴스. 실제로 메모리에 할당되어 동작하는 모양을 갖춘 것, instance
  - 객체는 자신 고유의 속성이 있으며 클래스에서 정의한 행위를 할 수 있다
  - 스위프트에서는 객체라는 용어보다는 클래스의 인스턴스라는 표현을 사용한다
  - 객체와 인스턴스는 동의어가 아님. '객체 == 클래스의 인스턴스', '객체 != 인스턴스'. 즉, 인스턴스는 구조체의 인스턴스도 있고 열거형의 인스턴스도 있을 수 있기 때문에 객체는 인스턴스 중에도 클래스의 인스턴스만 가리키는 말로 좀 더 한정적인 의미이다

- 메소드 또는 메시지

  - 객체가 클래스에 정의된 행위를 실질적으로 하는 함수이다
  - 메소드(메시지)를 통해 객체에 명령을 전달할 수 있음
  - 객체 간에 명령 전달 또는 데이터 전달은 메소드(메시지)를 통해 이루어지며 명령을 전달하거나 데이터를 전달하는 행위를 메소드를 호출한다 또는 메시지를 전달한다라고 표현함

  ```swift
  class SomeClass {
  	var someProperty: Any = 1
    func someMethod() {
      // some task ...
    }
  }
  
  //SomeClass라는 이름의 클래스의 이니셜라이저를 호출하여, myInstance라는 이르므이 상수에 할당함.
  //클래스의 이니셜라이저를 통해 메모리에 할당되고 초기화한 객체를 인스턴스라고 부른다
  let myInstance: SomeClass = SomeClass()
  myInstance.someProperty = 100		//set
  print(myInstance.someProperty)	//get
  myInstance.someMethod()					//call
  ```

- 스위프트 뿐만 아니라 객체지향 프로그래밍 패러다임을 차용한 언어는 필수로 명령형 프로그래밍 패러다임을 사용한다. 프로퍼티, 변수 등에 해당하는 메모리 값의 변화(상태변화)가 있기 때문

- 클래스는 객체가 만들어지기 위한 청사진으로 비유할 수 있다. 클래스는 실제 메모리에 객체를 할당해 인스턴스를 만들기 위한 일종의 설계코드임. 클래스에 구현된 코드대로 실제로 객체가 메모리에 올라가 활동하게 된다. 클래스에 정의된 모양대로 객체가 생성되고 객체간의 메시지를 통해 프로그램의 각 명령이 실행된다

## 함수형 프로그래밍 패러다임

- OO(Object Oriented) makes code understandable by encapsulating moving parts - Michael Feathers

  - 변하는 부분을 encapsulation해서 감추는 것에 중점
  
- FP(functional programming) makes code understandable by minmizing moving code parts - Michael Feathers

  - 움직이는 부분을 최소화해서 이해가능한 코드를 만드는 것

- #### Object oriented programming

  - 객체 기반
  - Object = field(variable) + method(function)
    variable과 function이 클래스로 되어서 object를 찍어냄
  - 메소드는 객체 내부 변수를 참조하여 return value를 생성
  - 개념: PIE(Polymorphism, Inheritance, Encapsulation)
  - 장점
    - 현실 세계를 반영한 객체 기반의 설계
    - 코드에 대한 이해도가 빠름
    - 대규모 시스템 설계에서 유리
  - 단점
    - 공유 자원에 대한 race condition
    - Dead lock, starvation 등 사이드이팩트 단점 유발
    - 이전에는 이런 문제들이 크게 부각되지 않았는데, 컴퓨팅 파워가 좋아지면서 parallel programming이 유행하면서 공유 자원에 대한 race condition에 대한 이슈 부각 

- #### 이걸 해결하기 위해 나온 Functional Programming

- 함수형 프로그래밍 패러다임은 프로그램이 상태의 변화 없이 데이터 처리를 수학적 함수 계산으로 취급하고자 하는 패러다임이다

  - 최근 프로그래밍 패러다임의 대세
  - 함수형 프로그래밍 패러다임의 가장 큰 장점은 대규모 병렬처리가 굉장히 쉽다는 점이다
  - 필요한 만큼 함수를 나누어 처리할 수 있도록 스케일업할 수 있기 때문에 대규모 병렬처리에 큰 강점이 있다
  - 기존 객체지향 프로그래밍 패러다임이나 명령형 프로그래밍 패러다임에서는 프로그램에서 값이나 상태의 변화를 중요하게 여기지만,
  - 함수형 프로그래밍 패러다임은 함수 자체의 응용을 중요하게 여긴다

- 수학적 함수와 명령형 함수의 차이점은 코드 이해와 실행 관점에서도 큰 차이를 보인다

  - 명령형 함수를 이용하는 객체지향 프로그래밍은 과거의 유산이라고도 볼 수 있는 절차지향 프로그래밍 패러다임이 포함되어있다. 그래서 함수 실행 시 함수가 전달받은 전달인자 외에도 포인터, 레퍼런스 값 등 객체의 상태 값(프로퍼티 값) 또는 메모리 참조 값 등이 변경될 수 있으며 함수 내부의 처리에도 영향을 미칠 수 있다
  - 하지만 수학적 함수를 이용하는 함수형 프로그래밍은 순수하게 함수에 전달된 인자 값만 결과에 영향을 주므로 상태 값을 갖지 않고 순수하게 함수만으로 동작한다. 따라서 어떤 상황에서 프로그램을 실행하더라도 일정하게 같은 결과를 도출할 수 있다
  - 프로그램이 동작하는 흐름에서 상태가 변하지 않으면 함수 호출이 각각 상호 간섭 없이 배타적으로 실행되므로 병렬처리할 때 부작용이 거의 없다
  - 프로세스 혹은 스레드 별로 특정 값을 참조하기 위해 락을 걸거나 대기할 필요가 없기 때문

- 함수 기반 f(x) = y

  - 단, 함수는 매개변수를 제외한 다른 외부변수를 참조하지 않는다
  - 다른 외부 변수를 참조하지 않기 때문에 함수 내부의 변수는 유일한 변수. 외부 영향을 받지 않아서 사이드이팩트가 적고, race condition에 어느정도 대응 가능
  - x에 대한 함수의 출력은 항상 f(x) 보장. 로직과 데이터 무결성에 대한 좋은 효과를 볼 수 있음
  - 설계 목적
    - 각 함수에 대한 참조 무결성을 보장
    - 병렬, 비동기 처리에 대한 내성 강화 
  - 함수형 프로그래밍을 하는 이유는 객체지향 프로그래밍보다 단순해서이다 - Neal Ford

- FP에서 제거대상

  - Local variable. 내부적으로 참고하고 있는 변수, 클래스나 객체 내에서 가지고 있어서 참조하는 외부변수
  - Loop for while, 외부변수 참조해서 돌아가기 때문에 ex) i가 도중에 변경하면 데이터 무결성 보장할 수 없기 때문
  - Assignment. 값을 할당하는 부분

- 함수가 일급 객체가 된다는 의미?

  - 다양한 종류의 함수를 호출하고, 전달하고, 반환하는 등의 동작만으로도 프로그램을 구현할 수 있다는 뜻. 함수가 일급 객체이므로 전달인자 또는 반환 값으로 사용할 수 있다
  - 다음 조건을 모두 충족해야 함수가 일급 객체가 될 수 있다

    - 전달인자로 전달할 수 있음
    - 동적 프로퍼티 할당이 가능함
    - 변수나 데이터 구조 안에 담을 수 있음
    - 반환 값으로 사용할 수 있음
    - 할당할 때 사용된 이름과 관계없이 고유한 객체로 구별할 수 있음
  - 기존의 스칼라 타입인 정수, 실수 등은 거의 모든 언어에서 일급 객체의 조건을 갖출 수 있지만, 대부분의 함수는 그렇지 않음. 하지만 스위프트의 함수는 이 조건을 모두 충족할 수 있기에 함수를 일급 객체로 취급함

- 또한 함수형 프로그래밍 패러다임은 위에 제시한 간단한 차이 외에도 closure, monad, functor, partial application, currying, high order function(map, filter, reduce, flatmap, flattern) 등의 기능을 사용할 수 있다

  ```swift
  func doSomething() {
    print("do something")
  }
  
  func doAnotherThing() {
    print("do another thing")
  }
  
  func executeAll() {
    doSomething()
    doAnotherThing()
  }
  
  executeAll()
  ```

  ```swift
  func doSomething() {
    print("do something")
  }
  
  func doAnotherThing() {
    print("do another thing")
  }
  
  func execute(tasks: [() -> Void]) {
  	for task in tasks {
      task()
    }
  }
  
  execute(tasks: [doSomething, doAnotherThing])
  ```

  ```swift
  func sum(first: Int, second: Int) -> Int {
    return first + second
  }
  
  sum(first: 10, second: 5)
  ```

  ```swift
  //currying: 전달인자를 하나만 두고 반환하면서 second in first + second처럼 전달인자 사용
  //여러 개의 매개변수를 갖는 함수를 매개변수 하나를 갖는 함수의 나열로 표현하는 방법
  func sum(first: Int) -> ((Int) -> Int) {
    return { second in first + second }
  }
  
  sum(first: 10)(5)
  ```

## 프로토콜 지향 프로그래밍 패러다임

- 심지어 WWDC에서 스위프트 표준 라이브러리의 테크니컬 리더인 데이브 에이브러햄이 직접 스위프트는 프로토콜 지향 언어라고 선언했다. 그는 프로토콜 지향 프로그래밍은 참조 타입인 클래스의 인스턴스보다 값 타입을 더 효율적으로 사용하며, 오류를 줄일 방안이라고 소개했다

- 스위프트에서는 구조체와 열거형에 기존의 클래스에서 구현할 수 있었던 캡슐화, 추상화, 접근제어 등의 기능을 모두 구현할 수 있다

- 더불어 프로토콜에 익스텐션을 활용할 수 있기 때문에 프로토콜 지향 프로그래밍이 가능해졌다

- 이는 참조 타입의 참조 문제에서 조금 더 자유로울 수 있고, 다중상속이 불가능한 한계를 뛰어넘을 수 있으며, 더 나은 추상화 메커니즘을 구현할 수 있다는 것이다

- 실제로 스위프트의 프로토콜 지향 프로그래밍 기법은 프로토콜 익스텐션 기능을 통해 완성 되었으며 강력해졌다.

- ### 프로토콜 지향 프로그래밍을 추구하는 이유

  - 구조체, 클래스 열거형 등 구조화된 타입 중에 상속은 클래스 타입에서만 가능하다
    - 클래스는 참조타입이므로 참조추적에 비용이 많이 발생한다. 비교적 비용이 적은 값타입을 활용하고 싶어도, 상속을 할 수 없으므로 때마다 기능을 다시 구현해주어야 했다
    - 하지만, 프로토콜 지행 프로그래밍은 그 한계를 없앴다
    - 또한, 구조체  열거형 타입을 사용하므로 속도도 더 빨라지는 장점이 있음
  - 기능의 모듈화가 더욱 명확해진다
    - 클래스가 상속을 할 수 있도록 설계되어 있다고 해도, 다중상속을 지원하는 언어는 많지 않다
    - 다중상속을 지원하지 않는다는 것은 하나의 상속체계에 속해있는 기능을 끌어다 쓸 수 없다는 뜻이다
    - 그런데 프로토콜 지향 프로그래밍은 기능을 프로토콜이라는 단위로 묶어 표현하고 초기구현을 해둘 수 있으니 상속이라는 한계점을 탈피할 수 있음

## RxSwift

> ### 왜 Rx???
>
> - 출처: https://huns.me/development/2051
> - 정확히 당시에 어떤 문제를 해결하기 위해서 Reactive Framework를 만들었는지는 알 수 없다.
>   다만 JavaScript와 같은 이벤트 기반의 동적 언어와 C# 같은 정적 언어 간의 코드 호환성을 맞추려다보면 필연적으로 비동기 로직을 쉽게 처리할 수 있는 방법을 고민했을 것이고, 이를 해결하는 과정에서 Reactive Framework를 만들지 않았을까?
>
> - Rx는 어떻게 문제를 해결하는가?
>   앞에서 Rx의 탄생 배경이 비동기 프로그래밍 문제를 해결하는 데 있다고 했다. 비동기 프로그래밍은 어렵다. 비동기 코드가 많아지면 제어의 흐름이 복잡하게 얽혀 코드를 예측하기 어려워진다. 따라서 전통적인 절차적 프로그래밍으로는 이 문제를 풀기가 쉽지 않다.
>
> - 그렇다면 Rx는 어떻게 비동기 프로그래밍 문제를 해결한다는 걸까? 이제부터 Rx가 제안하는 대안을 알아보자. 핵심 키워드는 리액티브 프로그래밍과 LINQ다.
>
> - 리액티브 프로그래밍
>   - 소프트웨어를 둘러싼 요즘의 환경은 과거와 많이 달라졌다. 인터넷 환경이 발달하면서 트래픽이 전에 비해 엄청나게 증가하였고, 무어의 법칙은 한계에 도달했다.
>   - 멀티 코어 프로세서에서 대안을 찾기 시작하면서 동시성 프로그래밍이 중요해졌다. 클라우드 컴퓨팅 환경도 등장했다. 
>   - 사용자 요구사항은 점점 까다로워져 더 정교하고 화려한 UI 인터랙션과 더 빠른 반응 속도를 요구한다. 전에 비해 훨씬 복잡해진 소프트웨어의 안정성은, 언제나 중요한 문제다.
>
> - 리액티브  매니페스토는 이 시대의 소프트웨어는 좋은 반응성(Responsive)을 가져야 하며, 좋은 반응성을 갖기 위해 회복탄력성(Resilient)과 유연성(Elastic)을 갖도록 시스템을 설계해야 한다고 주장한다. 이를 달성할 수 있는 방법으로 메시지(Message-Driven)로 시스템과 시스템, 모듈과 모듈을 연결하는 방법을 제안한다. 결국 비동기 처리를 적극 활용하는 데에서 문제의 해법을 찾는다.
>
> - 이 정의에는 리액티브 프로그래밍의 목적이 빠져있다. 무엇을 위해서, 데이터 플로우 관점에서 사고하고, 변경을 전파하는 걸까? 
>   리액티브 프로그래밍의 처음 시작이 어디인지는 명확하지 않다. 다만 추측할 수 있는 단서는 있다. 1985년에 David Harel, Amir Pnueil가 발표한 On the development of reactive systems라는 논문에 처음으로 리액티브 시스템(Reactive Systems)이라는 용어가 등장한다.
>
> - 즉, 리액티브 시스템이란 외부에서 들어오는 요청에 계속해서 응답하는 시스템이다. 이 논문은 리액티브 시스템을 구현하는 데에 적합한 프로그래밍 방법론에 대한 이야기를 담고 있는데, 이를 리액티브 프로그래밍으로 이해할 수 있다.
>   여기에서 힌트를 하나 얻었다. 계속해서 응답한다는 건 ‘반응’한다는 뜻이다. 그렇다면 리액티브 프로그래밍의 목적이 외부에서 들어온 자극에 반응하는 구조를 만드는 데 있다고 볼 수 있지 않을까? 여기에서 ‘반응’은 아래 두 가지 의미를 내포한다.
>
> - 자극은 밖에서 안으로 흐른다. 자극이 있어야만 반응하는 수동성을 갖는다.
>   정리하자면 프로그램이 외부와 상호 작용하는 방식을 거꾸로 뒤집어서 수동적 반응성을 획득하는 일, 이것이 리액티브 프로그래밍의 목적이다.
>
> ---
>
> - Rx: Reactive Extensions
> - Functional Reactive Programming
>   - Functional programming
>   - Data flows
>   - Propagation of change
> - Observable: 비동기적으로 다수의 이벤트를 다루는 방법. Observer 패턴의 확장
> - Observable: 이벤트의 스트림
> - ReactiveX는 Functional Reactive Programming의 구현체, 이벤트를 발생하는 observable과 이것을 관찰하는 observer를 통해 비동기 이벤트들을 쉽고 안전하게 처리할 수 있는 라이브러리. iOS에서는 RxSwift로 사용가능함
> - observable 스트림을 사용하는 비동기 프로그래밍 api
> - Functional reactive programming은 시간이 흐르면서 연속적으로 변하는 값들을 처리하는 반면 ReactiveX는 시간이 흐르면서 발행되는 이산 값들을 처리한다
> - 리액티브 프로그래밍은 비동기와 이벤트 기반의 데이터 스트리밍(Asynchronous and Event -based Data Streaming)을 Observable sequences로 변환해 개발하는 프로그래밍 방식이다
> - 현재는 인터넷 보급과 모바일 기기의 보급으로 365일 24시간 무정지의 끊김없는 빠른 서비스를 제공해야 한다. 이를 위해서는 장애에 빨리 복구되고, 서비스의 수평적 확장이 용이해야하며, Resilient와 Scalable 바탕에는 느슨한 결합(loose coupling)의 메세지 기반(Message Driven) 아키텍처가 기반이 되어야한다.
> - 사용자들이 이미지를 다운받거나 네트워크 통신을 하고 친구를 추가하는 활동을 좋아하므로 인터넷은 필수이고, IO를 아주 많이 사용하게 됩니다. 따라서 기기 메모리를 넘어선 영역, 즉 사용자 상호작용, 다른 기기, 카메라, 디스크 등과 여러 요소와 소통해야합니다. 이런 비동기적인 활동은 실패할 수 있고 문제 발생 가능성도 높다
> - 우리는 비동기 이벤트를 마치 iterable 컬렉션처럼 간단하게 다룰 권리가 있다

- Rx 간신히 써본 정도라 뭔지 정도만 언급

- reactive extension

- reactive programming paradigm: In computing, reactive programming is a programming paradigm oriented around data flows and the propagation of change

- 직관적인 예제, 스프레드 시트, 데이터를 넣으면 변화되고 흘러서 어딘가에 도달

- functional reactive programming paradigm: Functional reactive programming is a programming paradigm for reactive programming(asynchronous data flow programming) using the building blocks of functional programming(e.g. map, reduce, filter)

- Functional programming / Data flows / propagation of change

- Procedural way: 1부터 10까지 더하는 문제

  ```swift
  //sum에다가 상태를 저장해가면서
  var sum = 0
  for i in 1...10 {
  	sum+= 1
  }
  print(sum)
  ```

  ```swift
  //상태를 저장하지 않음. 중간에 변화되는 값이 없음
  print((1...10).reduce(0)) { $0 + $1 }
  ```

- Data flow

  ```swift
  //함수를 연결해가면서 데이터의 흘려보냄
  (1...10)
  	.filter {
  		$0 % 2 ==0	// 2, 4, 6, 8, 10
  	}.map {
      $0 * 10			// 20, 40, 60, 80, 100
    }.reduce(0) {
      $0 + $1			// 300
    }
  ```

- Propagation of change

  ```swift
  //처음 들어가는 데이터를 변경하면, 도출되는 결과도 변경됨
  (1...5)
  	.filter {
  		$0 % 2 ==0	// 2, 4
  	}.map {
      $0 * 10			// 20, 40
    }.reduce(0) {
      $0 + $1			// 60
    }
  ```

- ReactiveX가 FRP(functional reactive programming)의 구현체. An API for asynchronous programming with observable streams

- Observable: 비동기적으로 다수의 이벤트를 다루는 방법

- observable streams, 이벤트가 발생하면 조작해서 구독할 수 있게

- Stream에 나타나는 이벤트 그림

- |             | Iterable(pull)   | Observable(push)   |
  | ----------- | ---------------- | ------------------ |
  | 데이터 받기 | T next()         | onNext(T)          |
  | 에러 발견   | Throws Exception | onError(Exception) |
  | 완료        | !hasNext()       | onCompleted()      |

  ```
  Observable.create<String> { observer in
  	observer.onNext("🐶")
  	observer.onNext("🐰")
  	observer.onNext("🦊")
  	observer.onCompleted()
  }.subscribe {
  	print($0)
  }
  //🐶🐰🦊
  ```